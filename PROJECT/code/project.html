<!DOCTYPE html>
<html>

<head>
</head>

<body>
  <button>Click</button>

    <canvas id="webgl_canvas" width="1400" height="800"></canvas>
    <div id="fps"></div>
    <div id="camera_mat"></div>
    <div id="proj_mat"></div>

    <script src="../gl-matrix-min.js"></script>
    <script language="javascript" type="text/javascript" src="../camera.js"></script>
    <script language="javascript" type="text/javascript" src="../shaders.js"></script>
    <script language="javascript" type="text/javascript" src="textures_08.js"></script>
    <script language="javascript" type="text/javascript" src="objects_02.js"></script>
    <script>

    //<h1>Project: Rym Ouachi & Margaux Mannaerts</h1>
        async function main() {
            // Boilerplate code
            const canvas = document.getElementById('webgl_canvas');
            c_width = canvas.width
            c_height = canvas.height
            const gl = canvas.getContext('webgl');

            // Enable tests for better rendering
            gl.enable(gl.DEPTH_TEST);
            //gl.enable(gl.CULL_FACE); // cull hidden faces behind normals!


//CUBEMAP SHADERS
            const source_cubemap_V = `
              attribute vec3 position;
              attribute vec2 texcoord;
              attribute vec3 normal;
              varying vec3 v_texcoord;

              uniform mat4 M;
              uniform mat4 itM;  // inverse transpose model!
              uniform mat4 V;
              uniform mat4 P;

              void main() {
                mat3 Vrotation = mat3(V);
                vec4 frag_coord = vec4(position, 1.0);
                gl_Position = (P*mat4(Vrotation)*frag_coord).xyww;

                v_texcoord = frag_coord.xyz;
              }
            `;

            const source_cubemap_F = `
              precision mediump float;
              varying vec3 v_texcoord;

              // We have a samplerCube this time! not a 2D texture
              uniform samplerCube u_cubemap;

              void main() {
                //gl_FragColor = texture2D(u_texture, vec2(v_texcoord.x, 1.0-v_texcoord.y));
                // We sample the cube at the position of the vertices!
                gl_FragColor = textureCube(u_cubemap, v_texcoord);
              }
            `;

//REFRACTION SHADERS
            const source_refract_V = `
              attribute vec3 position;
              attribute vec2 texcoord;
              attribute vec3 normal;

              varying vec3 v_normal;
              varying vec3 v_frag_coord;

              uniform mat4 M;
              uniform mat4 itM;  // inverse transpose model!
              uniform mat4 V;
              uniform mat4 P;

              void main() {
                vec4 frag_coord = M*vec4(position, 1.0);
                gl_Position = (P*V*frag_coord);
                v_normal = vec3(itM * vec4(normal, 1.0));
                v_frag_coord = frag_coord.xyz;
              }
            `;

            const source_refract_F = `
                precision mediump float;

                varying vec3 v_normal;
                varying vec3 v_frag_coord;

                // We need the camera position to display a reflection/refraction!
                uniform vec3 u_view_dir;
                // This time We need the cubemap to display a reflection/refraction!
                uniform samplerCube u_cubemap;

                void main() {
                  /*
                      Refraction indices:
                      Air:      1.0
                      Water:    1.33
                      Ice:      1.309
                      Glass:    1.52
                      Diamond:  2.42
                  */
                  float ratio = 1.00 / 1.52;
                  vec3 I = normalize(v_frag_coord - u_view_dir);
                  vec3 R = refract(I, normalize(v_normal), ratio);
                  gl_FragColor = vec4(textureCube(u_cubemap, R).rgb, 1.0);
                }
            `;

//REFLECTION SHADERS
            const source_reflect_V = `
              attribute vec3 position;
              attribute vec2 texcoord;
              attribute vec3 normal;

              varying vec3 v_normal;
              varying vec3 v_frag_coord;

              uniform mat4 M;
              uniform mat4 itM;  // inverse transpose model!
              uniform mat4 V;
              uniform mat4 P;

              void main() {
                vec4 frag_coord = M*vec4(position, 1.0);
                gl_Position = (P*frag_coord);
                v_normal = vec3(itM * vec4(normal, 1.0));
                v_frag_coord = frag_coord.xyz;
              }
            `;

            const source_reflect_F = `
              precision mediump float;

              varying vec3 v_normal;
              varying vec3 v_frag_coord;


              uniform vec3 u_view_dir; // We need the camera position to display a reflection/refraction!

              uniform samplerCube u_cubemap; // This time We need the cubemap to display a reflection/refraction!

              void main() {
                vec3 I = normalize(v_frag_coord - u_view_dir);
                vec3 R = reflect(I, normalize(v_normal));
                gl_FragColor = vec4(textureCube(u_cubemap, R).rgb, 1.0);
              }
            `;

//SOURCE SHADERS
            const sourceV = `
              attribute vec3 position;
              attribute vec2 texcoord;
              attribute vec3 normal;
              varying vec3 v_normal;
              varying vec3 v_frag_coord;

              uniform mat4 M;
              uniform mat4 itM;  // inverse transpose model!
              uniform mat4 V;
              uniform mat4 P;

              void main() {
                vec4 frag_coord = M*vec4(position, 1.0);
                gl_Position = P*V*frag_coord;

                // Transform correctly the normals!
                v_normal = vec3(itM * vec4(normal, 1.0));

                v_frag_coord = frag_coord.xyz;
              }
            `;

            const sourceF = `
            precision mediump float;
            varying vec3 v_normal;
            varying vec3 v_frag_coord;

            uniform vec3 u_light_pos;
            uniform vec3 u_light_pos2;
            uniform vec3 u_light_pos3;
            uniform vec3 u_view_dir;
            uniform float time;

            //attenuation factors
            float att1; //attenuation factor 1
            float att2; //attenuation factor 2
            float att3; //attenuation factor 3
            float c = 1.0; //constant attenuation
            float l = 0.2; //linear attenuation
            float q = 0.01; //quadratic attenuation

            void main() {
              vec3 normal = normalize(v_normal);

              // light color
              vec3 light_color = vec3(0.4, 0.0, 0.8);
              vec3 light_color2 = vec3(0.2, 0.6, 1.0);
              vec3 light_color3 = vec3(1.0, 1.0, 0.0);

              // Ambient
              float ambient = 0.1;

              vec3 L = normalize(u_light_pos - v_frag_coord);
              vec3 L2 = normalize(u_light_pos2 - v_frag_coord);
              vec3 L3 = normalize(u_light_pos3 - v_frag_coord);

              // Diffuse
              float diffusion = max(0.0, dot(v_normal, L));
              float diffusion2 = max(0.0, dot(v_normal, L2));
              float diffusion3 = max(0.0, dot(v_normal, L3));

              // specural
              float spec_strength = 0.8;
              vec3 view_dir = normalize(u_view_dir - v_frag_coord);
              vec3 reflect_dir = reflect(-L, normal);
              float spec = pow(max(dot(view_dir, reflect_dir), 0.0), 32.0);
              float specular = spec_strength * spec;

              vec3 reflect_dir2 = reflect(-L2, normal);
              float spec2 = pow(max(dot(view_dir, reflect_dir2), 0.0), 32.0);
              float specular2 = spec_strength * spec2;

              vec3 reflect_dir3 = reflect(-L3, normal);
              float spec3 = pow(max(dot(view_dir, reflect_dir3), 0.0), 32.0);
              float specular3 = spec_strength * spec3;

              //Attenuation factor
              float d1 = distance(u_light_pos, v_frag_coord);
              att1 = 1.0 / (c + l*d1 + q*d1*d1);

              float d2 = distance(u_light_pos2, v_frag_coord);
              att2 = 1.0 / (c + l*d2 + q*d2*d2);

              float d3 = distance(u_light_pos3, v_frag_coord);
              att3 = 1.0 / (c + l*d3 + q*d3*d3);


              //vec3 color = (ambient + specular + diffusion) * light_color;
              //vec3 color = ambient + (specular + diffusion) * att1 * light_color + (specular2 + diffusion2) * att2 * light_color2;
              //vec3 color = ambient + (specular + diffusion) * light_color + (specular2 + diffusion2) * light_color2;
              vec3 color = ambient + (specular + diffusion) * att1 * light_color + (specular2 + diffusion2) * att2 * light_color2 + (specular3 + diffusion3) * att3 * light_color3;


              float cst = mod(time, 1.0);
              gl_FragColor = vec4(color, 1.0)*cst;
            }
              `;

//TEXTURE SHADERS
            const source_texture_V = `
          		  attribute vec3 position;
          		  attribute vec2 texcoord;
          		  varying vec4 v_texcoord;

          		  uniform mat4 M;
                uniform mat4 itM;  // inverse transpose model!
          		  uniform mat4 V;
          		  uniform mat4 P;

          		  void main() {


          			gl_Position = P*M*V*vec4(position, 1);
          			v_texcoord = vec4(position,1);
          		  }
          		`;

        		const source_texture_F = `
        		  precision mediump float;
        		  varying vec4 v_texcoord;

        		  uniform sampler2D u_texture;

        		  void main() {
                vec2 longitudeLatitude = vec2((atan(v_texcoord.y, v_texcoord.x) / 3.1415926 + 1.0) * 0.5,
                                          (asin(v_texcoord.z) / 3.1415926 + 0.5));
        			  gl_FragColor = texture2D(u_texture, longitudeLatitude);
        		  }
          		`;

              // SHADERS TEST
            const source_lighttex_V = `
          		  attribute vec3 position;
          		  attribute vec2 texcoord;
          		  varying vec4 v_texcoord;

                //ADDED FROM LIGHT
                attribute vec3 normal;
                varying vec3 v_normal;
                varying vec3 v_frag_coord; //it's kind of the same as v_texcoord

          		  uniform mat4 M;
                uniform mat4 itM;  // inverse transpose model!
          		  uniform mat4 V;
          		  uniform mat4 P;

          		  void main() {


          			gl_Position = P*M*V*vec4(position, 1);
          			v_texcoord = vec4(position,1);

                //LIGHT

                vec4 frag_coord = M*vec4(position, 1.0);
                //gl_Position = P*V*frag_coord;
                // Transform correctly the normals!
                v_normal = vec3(itM * vec4(normal, 1.0));

                v_frag_coord = frag_coord.xyz;

                //both together
          		  }
          		`;

        		const source_lighttex_F = `
        		  precision mediump float;
        		  varying vec4 v_texcoord;

        		  uniform sampler2D u_texture;


              //_____LIGHT_____
              varying vec3 v_normal;
              varying vec3 v_frag_coord; //kind of same as v_texcoord

              uniform vec3 u_light_pos;
              uniform vec3 u_view_dir;
              uniform float time;

        		  void main() {
                //vec2 longitudeLatitude = vec2((atan(v_frag_coord.y, v_frag_coord.x) / 3.1415926 + 1.0) * 0.5,
                 //                         (asin(v_frag_coord.z) / 3.1415926 + 0.5));
                vec2 longitudeLatitude = vec2((atan(v_texcoord.y, v_texcoord.x) / 3.1415926 + 1.0) * 0.5,
                                          (asin(v_texcoord.z) / 3.1415926 + 0.5));
        			  vec4 texture = texture2D(u_texture, longitudeLatitude);
                //gl_FragColor = texture2D(u_texture, longitudeLatitude);

                //_________LIGHT______________

                vec3 normal = normalize(v_normal);

                // light color
                vec3 light_color = vec3(1.0, 1.0, 1.0);

                // Ambient
                float ambient = 0.1;

                vec3 L = normalize(u_light_pos - v_frag_coord);

                // Diffuse
                float diffusion = max(0.0, dot(v_normal, L));

                // specural
                float spec_strength = 0.5;
                vec3 view_dir = normalize(u_view_dir - v_frag_coord);
                vec3 reflect_dir = reflect(-L, normal);
                float spec = pow(max(dot(view_dir, reflect_dir), 0.0), 32.0);
                float specular = spec_strength * spec;

                vec3 color = (ambient + specular + diffusion) * light_color;
                //vec3 color = (ambient + specular + diffusion) * light_color + (ambient + specular2 + diffusion2) * light_color2;

                float cst = mod(time, 1.0);
                gl_FragColor = texture*0.8 + vec4(color, 1.0)*0.2;
                //gl_FragColor = texture;
                //gl_FragColor = vec4(color, 1.0);

        		  }
          		`;

//TEXTURE BUMP MAPPING
          const source_Bump_V = `
            attribute vec3 position;
            attribute vec2 texcoord;
            varying vec4 v_texcoord;

            attribute vec3 tangent;
            attribute vec3 bitangent;
            varying mat3 TBN;

            //ADDED FROM LIGHT
            attribute vec3 normal;
            varying vec3 v_normal;
            varying vec3 v_frag_coord; //it's kind of the same as v_texcoord

            uniform mat4 M;
            uniform mat4 itM;  // inverse transpose model!
            uniform mat4 V;
            uniform mat4 P;

            void main() {
              vec3 T = normalize(vec3(M * vec4(tangent, 0.0)));
              vec3 B = normalize(vec3(M * vec4(bitangent, 0.0)));
              vec3 N = normalize(vec3(M * vec4(normal, 0.0)));
              mat3 TBN = mat3(T, B, N);

              gl_Position = P*M*V*vec4(position, 1);
              v_texcoord = vec4(position,1);

              //LIGHT
              vec4 frag_coord = M*vec4(position, 1.0);
              //gl_Position = P*V*frag_coord;
              // Transform correctly the normals!
              v_normal = vec3(itM * vec4(normal, 1.0));

              v_frag_coord = frag_coord.xyz;

            }
          		`;

          const source_Bump_F = `
            precision mediump float;
            varying vec4 v_texcoord;

            uniform sampler2D u_texture;
            //BUMP:
            uniform sampler2D u_normalMap;
            varying mat3 TBN;

            //_____LIGHT_____
            varying vec3 v_normal;
            varying vec3 v_frag_coord; //kind of same as v_texcoord

            uniform vec3 u_light_pos;
            uniform vec3 u_view_dir;
            uniform float time;

            void main() {
              //vec2 longitudeLatitude = vec2((atan(v_frag_coord.y, v_frag_coord.x) / 3.1415926 + 1.0) * 0.5,
               //                         (asin(v_frag_coord.z) / 3.1415926 + 0.5));
              vec2 longitudeLatitude = vec2((atan(v_texcoord.y, v_texcoord.x) / 3.1415926 + 1.0) * 0.5,
                                        (asin(v_texcoord.z) / 3.1415926 + 0.5));
              vec4 texture = texture2D(u_texture, longitudeLatitude);
              //gl_FragColor = texture2D(u_texture, longitudeLatitude);

              //BUMP MAP
              vec3 normal = texture2D(u_normalMap, longitudeLatitude).rgb;
              normal = normalize(normal * 2.0 - 1.0);
              //normal = normalize(TBN * normal);
              //_________LIGHT______________

              //vec3 normal = normalize(v_normal);

              // light color
              vec3 light_color = vec3(1.0, 1.0, 1.0);

              // Ambient
              float ambient = 0.1;

              vec3 L = normalize(u_light_pos - v_frag_coord);

              // Diffuse
              float diffusion = max(0.0, dot(normal, L));

              // specural
              float spec_strength = 0.5;
              vec3 view_dir = normalize(u_view_dir - v_frag_coord);
              vec3 reflect_dir = reflect(-L, normal);
              float spec = pow(max(dot(view_dir, reflect_dir), 0.0), 32.0);
              float specular = spec_strength * spec;

              //cos theta
              float dotprod = max(0.0, dot(L, normal));
              float costheta = dotprod / (length(u_light_pos)*length(normal));

              //SUM
              vec3 color = ambient + (specular + diffusion) * light_color; //* costheta;
              //vec3 color = (ambient + specular + diffusion) * light_color + (ambient + specular2 + diffusion2) * light_color2;

              float cst = mod(time, 1.0);


              gl_FragColor = texture*0.5 + vec4(color, 1.0)*0.5;
              //gl_FragColor = texture;
              //gl_FragColor = vec4(color, 1.0);

            }
                `;

            //------MAKING THE SHADERS------
            var shader_cubemap = make_shader(gl, source_cubemap_V, source_cubemap_F);
            // Shader for the cube
            var shader_refract = make_shader(gl, source_refract_V, source_refract_F);
            var shader_reflect = make_shader(gl, source_reflect_V, source_reflect_F); //shader for second object
            var shader_light = make_shader(gl, sourceV, sourceF);
            var shader_texture = make_shader(gl, source_texture_V, source_texture_F);
            var shader_lighttex = make_shader(gl, source_lighttex_V, source_lighttex_F);
            var shader_bump = make_shader(gl, source_Bump_V, source_Bump_F);


            //------LOADING, MAKING AND MOVING THE OBJECTS------
            var cube = await load_obj('../objects/cube.obj');
            var cube_mesh = await make_object(gl, cube);

            cube_mesh.model = glMatrix.mat4.scale(cube_mesh.model, cube_mesh.model,
                       glMatrix.vec3.fromValues(20.0, 20.0, 20.0));

            var sphere = await load_obj('../objects/sphere_smooth.obj');
            var earth_mesh = await make_object(gl,sphere);
  //Sun
            var sun_mesh = await make_object(gl,sphere);
            sun_mesh.model = glMatrix.mat4.translate(sun_mesh.model,
                                                         sun_mesh.model,
                                                         glMatrix.vec3.fromValues(0.0, 0.0, -20.0)); //(horizontal, up/down, dist from sun)

           var flash_mesh = await make_object(gl,sphere);
           flash_mesh.model = glMatrix.mat4.translate(flash_mesh.model,
                                                        flash_mesh.model,
                                                        glMatrix.vec3.fromValues(3.0, 3.0, 15.0));
  //Mercury
            var mercury_mesh = await make_object(gl,sphere);
            mercury_mesh.model = glMatrix.mat4.translate(mercury_mesh.model,
                                                       sun_mesh.model,
                                                       glMatrix.vec3.fromValues(0.0, 0.0, 10.0));

   //Venus
          var venus_mesh = await make_object(gl, sphere);
          venus_mesh.model = glMatrix.mat4.translate(venus_mesh.model,
                                                      sun_mesh.model,
                                                      glMatrix.vec3.fromValues(0.0, -1.0, 12.0));


  //Earth
            var earth_mesh = await make_object(gl, sphere);
            earth_mesh.model = glMatrix.mat4.translate(earth_mesh.model,
                                                        sun_mesh.model,
                                                        glMatrix.vec3.fromValues(0.0, 2.0, 18.0));
//Moon
           var moon_mesh = await make_object(gl, sphere);
           moon_mesh.model = glMatrix.mat4.translate(moon_mesh.model,
                                                       sun_mesh.model,
                                                       glMatrix.vec3.fromValues(-1.0, 4.0, 18.0));

  //Mars
            var mars_mesh = await make_object(gl, sphere);

            mars_mesh.model = glMatrix.mat4.translate(mars_mesh.model,
                                                      sun_mesh.model,
                                                      glMatrix.vec3.fromValues(0.0, -3.0, 22.0));

  //Jupiter
            var jupiter_mesh = await make_object(gl, sphere);
            jupiter_mesh.model = glMatrix.mat4.translate(jupiter_mesh.model,
                                                      sun_mesh.model,
                                                      glMatrix.vec3.fromValues(0.0, 1.0, 27.0));

  //Saturn
            var saturn_mesh = await make_object(gl, sphere);
            saturn_mesh.model = glMatrix.mat4.translate(saturn_mesh.model,
                                                      sun_mesh.model,
                                                      glMatrix.vec3.fromValues(0.0, -2.5, 30.0));

  //Uranus
            var uranus_mesh = await make_object(gl, sphere);
            uranus_mesh.model = glMatrix.mat4.translate(uranus_mesh.model,
                                                      sun_mesh.model,
                                                      glMatrix.vec3.fromValues(0.0, 0.0, 34.0));

  //Neptune
            var neptune_mesh = await make_object(gl, sphere);
            neptune_mesh.model = glMatrix.mat4.translate(neptune_mesh.model,
                                                      sun_mesh.model,
                                                      glMatrix.vec3.fromValues(0.0, 1.0, 37.0));


  //Satelite
            var sat = await load_obj('../objects/sat.obj');
            var sat_mesh = await make_object(gl, sat)
            sat_mesh.model = glMatrix.mat4.scale(sat_mesh.model, sat_mesh.model,
                                                       glMatrix.vec3.fromValues(0.001, 0.001, 0.001));
            sat_mesh.model = glMatrix.mat4.translate(sat_mesh.model,
                                                        sat_mesh.model,
                                                        glMatrix.vec3.fromValues(-0.5, 2.0, -20.0));



  //SPACESHIP
            var spaceship = await load_obj('../objects/spaceship.obj');
            var spaceship_mesh = await make_object(gl, spaceship);
            spaceship_mesh.model = glMatrix.mat4.translate(spaceship_mesh.model,
                                                            spaceship_mesh.model,
                                                        glMatrix.vec3.fromValues(0.0, -1.0, -3.0));
             spaceship_mesh.model = glMatrix.mat4.scale(spaceship_mesh.model, spaceship_mesh.model,
                                                        glMatrix.vec3.fromValues(0.01, 0.01, 0.01));
            spaceship_mesh.model = glMatrix.mat4.rotate(spaceship_mesh.model, spaceship_mesh.model,
                                                        3.14,
                                                        glMatrix.vec3.fromValues(0.0, 1.0, 0.0));

  //Asteroid 1
            var asteroid = await load_obj('../objects/steroid.obj');
            var asteroid_mesh1 = await make_object(gl, asteroid);
            asteroid_mesh1.model = glMatrix.mat4.translate(asteroid_mesh1.model,
                                                            asteroid_mesh1.model,
                                                        glMatrix.vec3.fromValues(-3.0, 1.0, 2.0));

            asteroid_mesh1.model = glMatrix.mat4.scale(asteroid_mesh1.model, asteroid_mesh1.model,
                                                       glMatrix.vec3.fromValues(0.001, 0.001, 0.001));

  //Asteroid 2
            var asteroid_mesh2 = await make_object(gl, asteroid);
            asteroid_mesh2.model = glMatrix.mat4.translate(asteroid_mesh2.model,
                                                            asteroid_mesh2.model,
                                                        glMatrix.vec3.fromValues(3.0, 1.0, 2.0));

            asteroid_mesh2.model = glMatrix.mat4.scale(asteroid_mesh2.model, asteroid_mesh2.model,
                                                       glMatrix.vec3.fromValues(0.001, 0.001, 0.001));


            //------MAKE THE LIGHTS------
            //* // We define a light in space and retrieve its ID in the shader
            const light_pos = glMatrix.vec3.fromValues(1.0, -1.6, -5.0);
            const u_light_pos = gl.getUniformLocation(shader_light.program, 'u_light_pos');

            const light_pos2 = glMatrix.vec3.fromValues(15.0, 6.6, -15.0);
            const u_light_pos2 = gl.getUniformLocation(shader_light.program, 'u_light_pos2');

            const light_pos3 = glMatrix.vec3.fromValues(-25.0, 0.0, -25.0);
            const u_light_pos3 = gl.getUniformLocation(shader_light.program, 'u_light_pos3');

            const light_pos_tex = glMatrix.vec3.fromValues(0.0, 0.0, -10.0);
            const u_light_pos_tex = gl.getUniformLocation(shader_lighttex.program, 'u_light_pos');

            const light_pos_bump = glMatrix.vec3.fromValues(10.0, 10.0, -10.0);
            const u_light_pos_bump = gl.getUniformLocation(shader_bump.program, 'u_light_pos');

            var u_time = gl.getUniformLocation(shader_light.program, "time");
            var u_time_lightTex = gl.getUniformLocation(shader_lighttex.program, "time");
            var u_time_bump = gl.getUniformLocation(shader_bump.program, "time");

            position = glMatrix.vec3.fromValues(-3.0, 0.0, -5.0)
            up = glMatrix.vec3.fromValues(0.0, 1.0, 0.0)
            yaw = -90.0
            pitch = 0.0
            var camera = make_camera(canvas, position, up, yaw, pitch)
            var projection = camera.get_projection(45.0, c_width / c_height, 0.01, 100.0)

            const camMatElem = document.querySelector("#camera_mat");
            const projMatElem = document.querySelector("#proj_mat");
            camera.show_projection_html(projMatElem, projection);

            // Retrieve the adress of the cubemap texture
            var texCube = make_texture_cubemap(gl, '../textures/cubemaps/galaxy2');
            const u_cubemap = gl.getUniformLocation(shader_cubemap.program, 'u_cubemap');

            // Retrieve the adress of the sphere1 texture
            var tex_mesh1 = make_texture(gl, '../textures/moonmap.jpg');
            const u_tex_mesh1 = gl.getUniformLocation(shader_lighttex.program,'u_texture');

            // Retrieve the adress of the sphere2 texture
            var tex_Earthmesh = make_texture(gl, '../textures/earthmap.jpg');
            const u_tex_Earthmesh = gl.getUniformLocation(shader_bump.program,'u_texture');

            var texnormal_Earthmesh = make_texture(gl, '../textures/earthbump.jpg');
            const u_texnormal_Earthmesh = gl.getUniformLocation(shader_bump.program,'u_normalMap');
//*/
            //sun texture

            var tex_mesh3 = make_texture(gl, '../textures/sun.jpeg');
            const u_tex_mesh3 = gl.getUniformLocation(shader_lighttex.program,'u_texture');

            //Mercury texture
            var tex_Mercurymesh = make_texture(gl, '../textures/mercury.jpeg');
            const u_tex_Mercurymesh = gl.getUniformLocation(shader_lighttex.program,'u_texture');

            //Venus texture
            var tex_Venusmesh = make_texture(gl, '../textures/venus.jpeg');
            const u_tex_Venusmesh = gl.getUniformLocation(shader_lighttex.program,'u_texture');

            //Mars texture
            var tex_Marsmesh = make_texture(gl, '../textures/mars.jpeg');
            const u_tex_Marsmesh = gl.getUniformLocation(shader_lighttex.program,'u_texture');

            //Jupiter texture
            var tex_Jupmesh = make_texture(gl, '../textures/jupiter.jpeg');
            const u_tex_Jupmesh = gl.getUniformLocation(shader_lighttex.program,'u_texture');

            //Saturn texture
            var tex_Satmesh = make_texture(gl, '../textures/saturn.jpeg');
            const u_tex_Satmesh = gl.getUniformLocation(shader_lighttex.program,'u_texture');

            //Uranus texture
            var tex_Uranusmesh = make_texture(gl, '../textures/uranus.jpeg');
            const u_tex_Uranusmesh = gl.getUniformLocation(shader_lighttex.program,'u_texture');

            //Neptune texture
            var tex_Nepmesh = make_texture(gl, '../textures/neptune.jpeg');
            const u_tex_Nepmesh = gl.getUniformLocation(shader_lighttex.program,'u_texture');

            // We need to send the inverse transpose of the model matrix for the model
            const u_itM = gl.getUniformLocation(shader_refract.program, 'itM');
            const u_itM_ref = gl.getUniformLocation(shader_reflect.program, 'itM');
            const u_itM_light = gl.getUniformLocation(shader_light.program, 'itM');
            const u_itM_texture = gl.getUniformLocation(shader_texture.program, 'itM');
            const u_itM_tex = gl.getUniformLocation(shader_lighttex.program, 'itM');
            const u_itM_bump = gl.getUniformLocation(shader_bump.program, 'itM');

            // We need to send the camera position to the shader
            const u_view_dir = gl.getUniformLocation(shader_refract.program, 'u_view_dir');
            const u_view_dir_ref = gl.getUniformLocation(shader_reflect.program, 'u_view_dir');
            const u_view_dir_light = gl.getUniformLocation(shader_light.program, 'u_view_dir');
            const u_view_dir_texture = gl.getUniformLocation(shader_texture.program, 'u_view_dir');
            const u_view_dir_tex = gl.getUniformLocation(shader_lighttex.program, 'u_view_dir');
            const u_view_dir_bump = gl.getUniformLocation(shader_bump.program, 'u_view_dir');

            //var earth_mesh =  createPlanet(earth_mesh, earth_position,earth_scale , shader_lighttex);


            sun_mesh.model = glMatrix.mat4.scale(sun_mesh.model, sun_mesh.model,
                                                        glMatrix.vec3.fromValues(10.0, 10.0, 10.0));
            saturn_mesh.model = glMatrix.mat4.scale(saturn_mesh.model, saturn_mesh.model,
                                                        glMatrix.vec3.fromValues(5.0, 5.0, 5.0));
            jupiter_mesh.model = glMatrix.mat4.scale(jupiter_mesh.model, jupiter_mesh.model,
                                                        glMatrix.vec3.fromValues(6.0, 6.0, 6.0));
                                                        //*
            mercury_mesh.model = glMatrix.mat4.scale(mercury_mesh.model, mercury_mesh.model,
                                                        glMatrix.vec3.fromValues(0.5, 0.5, 0.5));
            earth_mesh.model = glMatrix.mat4.scale(earth_mesh.model, earth_mesh.model,
                                                        glMatrix.vec3.fromValues(2.0, 2.0, 2.0));
            uranus_mesh.model = glMatrix.mat4.scale(uranus_mesh.model, uranus_mesh.model,
                                                        glMatrix.vec3.fromValues(4.0, 4.0, 4.0));
            neptune_mesh.model = glMatrix.mat4.scale(neptune_mesh.model, neptune_mesh.model,
                                                        glMatrix.vec3.fromValues(3.0, 3.0, 3.0));

            moon_mesh.model = glMatrix.mat4.scale(moon_mesh.model, moon_mesh.model,
                                                       glMatrix.vec3.fromValues(0.1, 0.1, 0.1));

           flash_mesh.model = glMatrix.mat4.scale(flash_mesh.model, flash_mesh.model,
                                                      glMatrix.vec3.fromValues(0.5, 0.5, 0.5));
//*/
            var deltaTime = 0;

            function animate(time) {
                deltaTime += 0.005;
                camera.update(deltaTime);
                //Draw loop
                gl.clearColor(0.2, 0.2, 0.2, 1);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


                //------DRAWING OF THE SCENE------


          //REFRACTION OBJECTS
                shader_refract.use();
                var unif = shader_refract.get_uniforms();
                view = camera.get_view_matrix();
                gl.uniformMatrix4fv(unif['view'], false, view);
                gl.uniformMatrix4fv(unif['proj'], false, projection);

                //refraction asteroid 1
                asteroid_mesh1.activate(shader_refract);
                gl.uniformMatrix4fv(unif['model'], false, asteroid_mesh1.model);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, asteroid_mesh1.model);
                itM = glMatrix.mat4.transpose(itM, itM);
                gl.uniformMatrix4fv(u_itM, false, itM);
                asteroid_mesh1.draw();
                gl.uniform3fv(u_view_dir, camera.get_position());

                asteroid_mesh1.model = glMatrix.mat4.rotate(asteroid_mesh1.model, asteroid_mesh1.model,
                                                       deltaTime/360,
                                                       glMatrix.vec3.fromValues(1, 1, 1));

               sat_mesh.activate(shader_refract);
               gl.uniformMatrix4fv(unif['model'], false, sat_mesh.model);
               var itM = glMatrix.mat4.create();
               itM = glMatrix.mat4.invert(itM, sat_mesh.model);
               itM = glMatrix.mat4.transpose(itM, itM);
               gl.uniformMatrix4fv(u_itM, false, itM);
               sat_mesh.draw();
               gl.uniform3fv(u_view_dir, camera.get_position());


               //BUMP MAP

               shader_bump.use();
               var unif5 = shader_bump.get_uniforms();
               view5 = camera.get_view_matrix();
               gl.uniformMatrix4fv(unif5['view'], false, view5);
               gl.uniformMatrix4fv(unif5['proj'], false, projection);
               gl.uniform3fv(u_light_pos_bump, light_pos_bump);
               gl.uniform3fv(u_view_dir_bump, camera.get_position());


             //Earth
               earth_mesh.activate(shader_bump);
               gl.uniformMatrix4fv(unif5['model'], false, earth_mesh.model);
               var itM = glMatrix.mat4.create();
               itM = glMatrix.mat4.invert(itM, earth_mesh.model);
               itM = glMatrix.mat4.transpose(itM, itM);
               gl.uniformMatrix4fv(u_itM_bump, false, itM);
               gl.uniform1f(u_time_bump, deltaTime);

               //gl.activeTexture(gl.TEXTURE0);
               gl.bindTexture(gl.TEXTURE_2D, texnormal_Earthmesh);
               gl.uniform1i(u_texnormal_Earthmesh, 0);
               gl.activeTexture(gl.TEXTURE0);
               gl.bindTexture(gl.TEXTURE_2D, tex_Earthmesh);
               gl.uniform1i(u_tex_Earthmesh, 0);

                earth_mesh.model = glMatrix.mat4.rotate(earth_mesh.model, earth_mesh.model,
                                                       deltaTime/3600,
                                                       glMatrix.vec3.fromValues(1, 1, 1));
                earth_mesh.draw();
                gl.uniform3fv(u_view_dir_bump, camera.get_position());


//TEXTURE OBJECTS
            // Mercury

            shader_lighttex.use();
            var unif2 = shader_lighttex.get_uniforms();
            view2 = camera.get_view_matrix();
            gl.uniformMatrix4fv(unif2['view'], false, view2);
            gl.uniformMatrix4fv(unif2['proj'], false, projection);
            gl.uniform3fv(u_light_pos_tex, light_pos_tex);
            gl.uniform3fv(u_view_dir_tex, camera.get_position());

                mercury_mesh.activate(shader_lighttex);
                gl.uniformMatrix4fv(unif2['model'], false, mercury_mesh.model);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, mercury_mesh.model);
                itM = glMatrix.mat4.transpose(itM, itM);
                gl.uniformMatrix4fv(u_itM_tex, false, itM);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_Mercurymesh);
                gl.uniform1i(u_tex_Mercurymesh, 0);


                glMatrix.mat4.rotate(mercury_mesh.model, mercury_mesh.model,
                                                                        deltaTime/3600,
                                                                         glMatrix.vec3.fromValues(-10.0, 0.0, -10.0));

                mercury_mesh.draw();
                gl.uniform3fv(u_view_dir_tex, camera.get_position());


//*
                // Venus
                venus_mesh.activate(shader_lighttex);
                gl.uniformMatrix4fv(unif2['model'], false, venus_mesh.model);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, venus_mesh.model);
                itM = glMatrix.mat4.transpose(itM, itM);
                gl.uniformMatrix4fv(u_itM_tex, false, itM);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_Venusmesh);
                gl.uniform1i(u_tex_Venusmesh, 0);

                glMatrix.mat4.rotate(venus_mesh.model,venus_mesh.model,
                                                                        deltaTime/3600,
                                                                         glMatrix.vec3.fromValues(-10.0, 0.0, -10.0));

                venus_mesh.draw();
                gl.uniform3fv(u_view_dir_tex, camera.get_position());

                // Mars
                mars_mesh.activate(shader_lighttex);
                gl.uniformMatrix4fv(unif2['model'], false, mars_mesh.model);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, mars_mesh.model);
                itM = glMatrix.mat4.transpose(itM, itM);
                gl.uniformMatrix4fv(u_itM_tex, false, itM);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_Marsmesh);
                gl.uniform1i(u_tex_Marsmesh, 0);

                mars_mesh.model = glMatrix.mat4.rotate(mars_mesh.model, mars_mesh.model,
                                                       deltaTime/3600,
                                                       glMatrix.vec3.fromValues(2, 2, 2));

                mars_mesh.draw();
                gl.uniform3fv(u_view_dir_tex, camera.get_position());

                //Jupiter
                jupiter_mesh.activate(shader_lighttex);
                gl.uniformMatrix4fv(unif2['model'], false, jupiter_mesh.model);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, jupiter_mesh.model);
                itM = glMatrix.mat4.transpose(itM, itM);
                gl.uniformMatrix4fv(u_itM_tex, false, itM);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_Jupmesh);
                gl.uniform1i(u_tex_Jupmesh, 0);

                jupiter_mesh.model = glMatrix.mat4.rotate(jupiter_mesh.model, jupiter_mesh.model,
                                                       deltaTime/3600,
                                                       glMatrix.vec3.fromValues(10, 7, 10));

                jupiter_mesh.draw();
                gl.uniform3fv(u_view_dir_tex, camera.get_position());

                //Saturn
                saturn_mesh.activate(shader_lighttex);
                gl.uniformMatrix4fv(unif2['model'], false, saturn_mesh.model);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, saturn_mesh.model);
                itM = glMatrix.mat4.transpose(itM, itM);
                gl.uniformMatrix4fv(u_itM_tex, false, itM);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_Satmesh);
                gl.uniform1i(u_tex_Satmesh, 0);

                saturn_mesh.model = glMatrix.mat4.rotate(saturn_mesh.model, saturn_mesh.model,
                                                       deltaTime/3600,
                                                       glMatrix.vec3.fromValues(0.0, 1.0, 3.0));
                saturn_mesh.draw();
                gl.uniform3fv(u_view_dir_tex, camera.get_position());
///*
                //Uranus
                uranus_mesh.activate(shader_lighttex);
                gl.uniformMatrix4fv(unif2['model'], false, uranus_mesh.model);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, uranus_mesh.model);
                itM = glMatrix.mat4.transpose(itM, itM);
                gl.uniformMatrix4fv(u_itM_tex, false, itM);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_Uranusmesh);
                gl.uniform1i(u_tex_Uranusmesh, 0);

                uranus_mesh.model = glMatrix.mat4.rotate(uranus_mesh.model, uranus_mesh.model,
                                                       deltaTime/3600,
                                                       glMatrix.vec3.fromValues(1, 1, 1));

                uranus_mesh.draw();
                gl.uniform3fv(u_view_dir_tex, camera.get_position());

                //Neptune
                neptune_mesh.activate(shader_lighttex);
                gl.uniformMatrix4fv(unif2['model'], false, neptune_mesh.model);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, neptune_mesh.model);
                itM = glMatrix.mat4.transpose(itM, itM);
                gl.uniformMatrix4fv(u_itM_tex, false, itM);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_Nepmesh);
                gl.uniform1i(u_tex_Nepmesh, 0);

                neptune_mesh.model = glMatrix.mat4.rotate(neptune_mesh.model, neptune_mesh.model,
                                                       deltaTime/3600,
                                                       glMatrix.vec3.fromValues(2.0, 6.0, 1.0));

                neptune_mesh.draw();
                gl.uniform3fv(u_view_dir_tex, camera.get_position());


                //Moon
                moon_mesh.activate(shader_lighttex);
                gl.uniformMatrix4fv(unif2['model'], false, moon_mesh.model);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, moon_mesh.model);
                itM = glMatrix.mat4.transpose(itM, itM);
                gl.uniformMatrix4fv(u_itM_tex, false, itM);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_mesh1);
                gl.uniform1i(u_tex_mesh1, 0);

                moon_mesh.draw();
                gl.uniform3fv(u_view_dir, camera.get_position());
//*
                moon_mesh.model = glMatrix.mat4.rotate(moon_mesh.model, moon_mesh.model,
                                       deltaTime/3600,
                                       glMatrix.vec3.fromValues(0, 0.01, 0));
//*/

                sun_mesh.activate(shader_lighttex);
                gl.uniformMatrix4fv(unif2['model'], false, sun_mesh.model);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, sun_mesh.model);
                itM = glMatrix.mat4.transpose(itM, itM);
                gl.uniformMatrix4fv(u_itM_tex, false, itM);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_mesh3);
                gl.uniform1i(u_tex_mesh3, 0);

                sun_mesh.draw();
                gl.uniform3fv(u_view_dir, camera.get_position());

            //REFLECTION OBJECTS
                shader_reflect.use();
                var unif2 = shader_reflect.get_uniforms();
                view2 = camera.get_view_matrix();
                gl.uniformMatrix4fv(unif2['view'], false, view2);
                gl.uniformMatrix4fv(unif2['proj'], false, projection);

                spaceship_mesh.activate(shader_reflect);
                // Only the model matrix changes!
                gl.uniformMatrix4fv(unif2['model'], false, spaceship_mesh.model);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, spaceship_mesh.model);
                itM = glMatrix.mat4.transpose(itM, itM);
                gl.uniformMatrix4fv(u_itM_ref, false, itM);
                spaceship_mesh.draw();
                gl.uniform3fv(u_view_dir_ref, camera.get_position());

          //LIGHT OBJECTS
                shader_light.use();
                var unif3 = shader_light.get_uniforms();
                view3 = camera.get_view_matrix();
                gl.uniformMatrix4fv(unif3['view'], false, view3);
                gl.uniformMatrix4fv(unif3['proj'], false, projection);
                // Send the light position to the shader
                gl.uniform3fv(u_light_pos, light_pos);
                gl.uniform3fv(u_light_pos2, light_pos2);
                gl.uniform3fv(u_light_pos3, light_pos3);

                flash_mesh.activate(shader_light);
                // Only the model matrix changes!
                gl.uniformMatrix4fv(unif3['model'], false, flash_mesh.model);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, flash_mesh.model);
                itM = glMatrix.mat4.transpose(itM, itM);
                gl.uniformMatrix4fv(u_itM_light, false, itM);
                gl.uniform1f(u_time, deltaTime);

                flash_mesh.model = glMatrix.mat4.rotate(flash_mesh.model,flash_mesh.model,
                                       deltaTime/3600,
                                       glMatrix.vec3.fromValues(0, 0.01, 0));

                flash_mesh.draw();
                gl.uniform3fv(u_view_dir_light, camera.get_position());


                // Add the viewer position
                console.log(typeof(camera.position))
                // Set one time the camera position for all the shaders
                gl.uniform3fv(u_view_dir_light, camera.get_position());



                // Activating textures

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texCube);
                gl.uniform1i(u_cubemap, 0);



                //------DRAWING THE CUBE MAP------
                //*    // uncomment only one slash "/" to comment the cubemap ;)
                // We draw the cubemap ONLY at the end!
                gl.depthFunc(gl.LEQUAL);
                shader_cubemap.use();
                cube_mesh.activate(shader_cubemap);

                var unif = shader_cubemap.get_uniforms();

                view = camera.get_view_matrix();
                gl.uniformMatrix4fv(unif['model'], false, cube_mesh.model);
                gl.uniformMatrix4fv(unif['view'], false, view);
                gl.uniformMatrix4fv(unif['proj'], false, projection);

                // Activate the texture for the cube
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texCube);
                gl.uniform1i(u_cubemap, 0);

                cube_mesh.draw();
                gl.depthFunc(gl.LESS);
                //*/


                sat_mesh.model = glMatrix.mat4.rotate(sat_mesh.model, sat_mesh.model,
                                                       deltaTime/3600,
                                                       glMatrix.vec3.fromValues(0.005, 0.05, 0.005));

                camera.show_view_html(camMatElem, camera.get_view_matrix());
                //fps(time);
                window.requestAnimationFrame(animate); // While(True) loop!
            }

            var prev = 0
            //const fpsElem = document.querySelector("#fps");

            function fps(now) {
              /*
                now *= 0.001;
                const deltaTime = now - prev;
                prev = now;
                const fps = 1 / deltaTime;
                fpsElem.textContent = 'FPS: ' + fps.toFixed(1);
                return fps;
              */
            }

            animate(0);
        }

        main();
    </script>
</body>

</html>
